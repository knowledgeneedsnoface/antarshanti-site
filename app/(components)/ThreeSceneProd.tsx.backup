"use client";

import React, { Suspense, useMemo, useRef, useState } from "react";
import { Canvas, useFrame, useThree } from "@react-three/fiber";
import { ScrollControls, useScroll, useTexture } from "@react-three/drei";
import * as THREE from "three";
import Signboard3D from "./Signboard3D";
import ThreeOverlayProd from "./ThreeOverlayProd";

/**
 * Production-ready 3D Journey
 * - ScrollControls driven camera along CatmullRom spline
 * - Environment lighting + soft directional light
 */

const SIGNS = [
  { id: "b1", position: [6, 0.7, -4], title: "Reduce Anxiety", image: "/benefit1.jpg", content: "A gentle 10-minute ritual to calm your nervous system." },
  { id: "b2", position: [14, 0.7, 1],  title: "Daily Focus",    image: "/benefit2.jpg", content: "Start each day with clarity and intention." },
  { id: "b3", position: [22, 0.7, -3], title: "Screen-free Pause", image: "/benefit3.jpg", content: "An offline habit to reset your mind." },
];

// spline points (world space)
function getSpline() {
  return new THREE.CatmullRomCurve3([
    new THREE.Vector3(0, 1.65, 0),
    new THREE.Vector3(6, 1.65, -4),
    new THREE.Vector3(12, 1.6, 2),
    new THREE.Vector3(18, 1.6, -2),
    new THREE.Vector3(26, 1.6, 0),
  ]);
}

function SplineCamera({ scroll }: { scroll: number }) {
  const { camera } = useThree();
  const spline = useMemo(() => getSpline(), []);
  
  useFrame(() => {
    const t = THREE.MathUtils.clamp(scroll, 0, 1);
    const pos = spline.getPointAt(t);
    const ahead = spline.getPointAt(Math.min(t + 0.02, 1));
    
    // Smooth camera movement
    camera.position.lerp(pos, 0.1);
    camera.lookAt(ahead);
    camera.updateMatrixWorld();
  });
  
  return null;
}

function Ground() {
  const tex = useTexture("/scene-bg.jpg");
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(10, 3);
  tex.colorSpace = THREE.SRGBColorSpace;

  return (
    <mesh rotation-x={-Math.PI/2} position={[13, -0.02, 0]} receiveShadow>
      <planeGeometry args={[80, 20]} />
      <meshStandardMaterial map={tex} metalness={0.0} roughness={1.0} />
    </mesh>
  );
}

export default function ThreeSceneProd({ onProceed }: { onProceed?: () => void }) {
  const [activeId, setActiveId] = useState<string | null>(null);
  const [visited, setVisited] = useState<Record<string, boolean>>({});

  return (
    <div className="w-full h-screen relative bg-gradient-to-b from-white to-amber-50">
      <Canvas 
        gl={{ antialias: true }} 
        camera={{ position: [0, 1.65, 0], fov: 60 }}
        shadows
      >
        <color attach="background" args={["#f9f5f0"]} />
        <fog attach="fog" args={["#f9f5f0", 10, 35]} />
        
        <ambientLight intensity={0.5} />
        <directionalLight 
          position={[10, 10, 5]} 
          intensity={1} 
          castShadow 
          shadow-mapSize-width={2048} 
          shadow-mapSize-height={2048}
          shadow-camera-far={50}
          shadow-camera-left={-20}
          shadow-camera-right={20}
          shadow-camera-top={20}
          shadow-camera-bottom={-20}
        />
        
        <Suspense fallback={null}>
          <ScrollControls pages={3} damping={0.2}>
            <SceneInner
              onSignClick={(id: string) => {
                setActiveId(id);
                setVisited((v) => ({ ...v, [id]: true }));
              }}
            />
          </ScrollControls>
        </Suspense>
      </Canvas>

      {/* HTML overlay - HUD, modal */}
      <ThreeOverlayProd
        activeSign={SIGNS.find(s => s.id === activeId) ?? null}
        onClose={() => setActiveId(null)}
        onContinue={() => {
          setActiveId(null);
        }}
        onProceed={onProceed}
        visited={visited}
      />
      
      {/* Scroll instruction */}
      <div className="absolute bottom-8 left-1/2 -translate-x-1/2 z-40 pointer-events-none">
        <div className="bg-white/90 px-6 py-3 rounded-full shadow-lg text-sm font-medium animate-bounce">
          Scroll to explore â†’
        </div>
      </div>
    </div>
  );
}

/**
 * Inner scene reads scroll progress and places objects
 */
function SceneInner({ onSignClick }: { onSignClick: (id: string) => void }) {
  const scroll = useScroll();
  const scrollOffset = useRef(0);

  useFrame(() => {
    scrollOffset.current = scroll.offset;
  });

  return (
    <>
      <SplineCamera scroll={scrollOffset.current} />
      
      <Ground />

      {/* Signboards */}
      {SIGNS.map((s) => (
        <Signboard3D key={s.id} data={s} onClick={() => onSignClick(s.id)} />
      ))}

      {/* Decorative elements */}
      <mesh position={[3, 0.5, -2]} castShadow>
        <boxGeometry args={[0.8, 1, 0.8]} />
        <meshStandardMaterial color="#8b6f47" />
      </mesh>
      
      <mesh position={[10, 0.3, 1]} castShadow>
        <sphereGeometry args={[0.3, 16, 16]} />
        <meshStandardMaterial color="#d4af37" metalness={0.8} roughness={0.2} />
      </mesh>
      
      <mesh position={[20, 0.4, -1]} castShadow>
        <cylinderGeometry args={[0.4, 0.4, 0.8, 8]} />
        <meshStandardMaterial color="#cd853f" />
      </mesh>
    </>
  );
}
